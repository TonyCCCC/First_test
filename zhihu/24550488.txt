由于译者时间及水平有限，翻译难免有误，欢迎批评指正！若发现有错误的地方可以在github repo中提交PR，感谢大家的支持！文档中还有部分没有翻译完，留给读者参与其中，共同学习进步，同时欢迎各路大神帮忙改进和review，Github地址：
https://
github.com/PyCN/PTR
原文
：
What’s New In Python 3.6
翻译团队
：
Py字幕组
首发刊物
：
PyCN技术评论
Github
：
PyCN/PTR
由阿橙(
@sinoandywong
)召集，Ele(
@ictar
)、苍冥(
@eastrd
)组织翻译。
译者
： 
eastrd
：苍冥 
ictar
 ：Ele 
linchart
szthanatos 
alex-marmot
heyuanree
sinoandywong
：阿橙 
sxqs-yang
:若木羊 
zilongcc
：水手 
bubuyo
:铲屎官 
yifan1024
YoungZiyi
fuckexception
Lving
LoveSn0w
phdhorse41
特别感谢
： 
Ele(
@ictar
)：她为本文档的翻译做了大量工作，一个热爱美食的菇凉。 
Py字幕组
：一个各路大(dou)神(bi)聚集的团队。
感谢他们所作出的工作，圣诞快乐！ 
2016.12.25
另请参阅这篇文章介绍了与3.5相比， Python 3.6中多出的新特性。
PEP 494
 - Python 3.6 发布时间表
摘要 - 发布亮点
新的语法特性：
PEP 498, 格式化字符串字面量
PEP 515, 数字字面量中的下划线
PEP 526, 变量注解中的语法
PEP 525, 异步生成器
PEP 520: 异步解析式
新的库模块
secrets
: PEP 506 - 在标准库中添加了Secrets模块
CPython实现的改进：
重新实现了
字典(dict)
类型，以便能像
PyPy的字典类型
一样使用更紧凑的表达方式。与Python 3.5相比，这使字典的内存用量减少了20%到25%。
用新协定优化了类的自定义建立。
类属性定义顺序(class attribute definition order)现在被保留了。
**kwargs内的元素顺序现在对应于将关键字(保留字）参数传递给函数的顺序。
新增了对DTrace和SystemTap probing的支持。
新PYTHONMALLOC环境变量现在可用于调试解释器内存分配与访问错误。
标准库的重大改进：
为
asyncio
模块开发了新功能、显著的可用性、性能优化，以及大量的错误修复。 从Python 3.6开始，asyncio模块不再是临时的了，其API也进入了稳定状态。
实现了用于支持
类路径对象(path-like objects)
的新文件系统路径协议。 所有在路径(path)上使用的标准库函数都已更新，以便适应于新协议。
datetime
模块已获得对本地时间消歧(Local Time Disambiguation)的支持。
针对
typing
模块的一些改进，使其不再是临时模块。
tracemalloc
模块已重大改进，现用于为ResourceWarning提供更好的输出，并为内存分配错误提供更好的诊断。 欲知详情，请参阅PYTHONMALLOC部分。
安全相关的改进:
新
secrets模块
被用于简化那些适用于管理密文的密码学安全伪随机数生成器(cryptographically strong pseudo-random numbers)的生成过程，如认证、token等。
在Linux上，现将
os.urandom()
改成了阻塞模式，直到系统的urandom的熵池(entropy pool)的初始化具有更高的安全性。 解释请参见
PEP 524
。
hashlib
和
ssl
模块现已支持OpenSSL 1.1.0。
改进了
ssl模块
的默认设置和特性集。
新增了
hashlib模块
对BLAKE2、SHA-3、SHAKE哈希算法以及
scrypt()
密钥导出函数的支持。
Windows上的改进:
PEP 528与PEP 529，Windows文件系统和控制台的编码已更改为UTF-8。
当用户没有指定版本（通过命令行参数或配置文件）时，py.exe启动器以交互方式使用时，不再以Python 2优先于Python 3。 处理shebang行的方式保持不变 - 此处的“python”依旧指Python 2。
python.exe和pythonw.exe已标记为长路径敏感(long-path aware)，这意味着260字符路径限制可能不再适用。 有关详细信息，请参阅
删除MAX_PATH限制
。
可以添加._pth文件以强制隔离模式(isolated mode)并完全指定所有搜索路径，以避免注册表查找和环境查找。 有关详细信息，请参阅
文档
。
一个python36.zip文件现可用作一个地标(landmark)以臆指
PYTHONHOME
。 有关详细信息，请参阅
文档
。
新特性
PEP 498: 格式化字符串
PEP 498
引入了一种新的字符串：_f-strings_, 或者
格式化字符串
。
格式化字符串带'f'前缀，类似于
str.format()
接受的格式字符串。它们包含了由花括号括起来的替换字段。替换字段是表达式，它们会在运行时计算，然后使用
format()
协议进行格式化：
    >>> name = "Fred"    >>> f"He said his name is {name}."    'He said his name is Fred.'    >>> width = 10    >>> precision = 4    >>> value = decimal.Decimal("12.34567")    >>> f"result: {value:{width}.{precision}}"  # nested fields    'result:      12.35'

又见
PEP 498
 - 字符串插值。
PEP由Eric V. Smith编写和实现。

特性文档
。
PEP 526: 变量注解语法
PEP 484
引入了函数参数的类型注释的标准，又名类型提示。这个PEP添加了用来注释变量（包括类变量和实例变量）类型的语法：
    primes: List[int] = []    captain: str  # Note: no initial value!    class Starship:        stats: Dict[str, int] = {}

正如函数注释，Python解释器不附加任何特殊意义到变量注解上，只是将它们存储在一个类或者模块的__annotations__属性中。
与静态类型语言中的变量声明相比，注释语法的目的在于提供一种简单的方式，通过抽象语法树和__annotations__属性，来为第三方工具和库指定结构化类型元数据。
又见
PEP 526
 - 变量注解语法。
PEP由Ryan Gonzalez, Philip House, Ivan Levkivskyi, Lisa Roach, 和Guido van Rossum编写。由Ivan Levkivskyi实现。

使用或将要使用这个新语法的工具：
mypy
, 
pytype
, PyCharm等等。
PEP 515: 数值文字中的下划线
PEP 515
添加了在数值文字中使用下划线的能力，以提高可读性。例如：
    >>> 1_000_000_000_000_000    1000000000000000    >>> 0x_FF_FF_FF_FF    4294967295

数字之间和任何基本符号之后允许单个下划线。不允许前置、后置或者多个连续的下划线。
字符串格式化
语言现在还支持'_'选项，该选项用来通知对浮点表示类型和整型表示类型'd'，会把下划线当成千位分隔符使用。对于整型表示类型'b', 'o', 'x', 和'X', 下划线将会被插入到每4个数字之间：
    >>> '{:_}'.format(1000000)    '1_000_000'    >>> '{:_x}'.format(0xFFFFFFFF)    'ffff_ffff'

又见
PEP 515
 - 数值文字中的下划线
PEP由Georg Brandl和Serhiy Storchaka编写。

PEP 525: 异步生成器
PEP 492
 引入支持原生协程和async /await的语法到Python 3.5。 在Python 3.5实现里的一个值得注意的 
局限性就在于它不可能使用await和`yield'在同一个函数体中。 而在Python 3.6中，这个限制 
已解除，这使得定义
异步生成器
成为可能：
    async def ticker(delay, to):        """Yield numbers from 0 to *to* every *delay* seconds."""        for i in range(to):            yield i            await asyncio.sleep(delay)

新的语法允许更快更简洁的代码。
参见 
PEP 525
 - 异步生成器
由Yury Selivanov撰写并实现的PEP。

PEP 530: 异步解析式
PEP 530
 添加了对async for在list、set、dict解析式以及generator表达式中的使用支持：
    result = [i async for i in aiter() if i % 2]

此外，所有解析式都支持“await”表达式：
    result = [await fun() for fun in funcs if await condition()]

参见 
PEP 530
 - 异步解析式
由Yury Selivanov撰写并实现的PEP。

PEP 487: 用于建立类的更简单的自定义
现在可以在不使用元类的情况下自定义子类。每当创建一个新的子类时，新的__init_subclass__类方法将在基类上被调用，：
    class PluginBase:        subclasses = []        def __init_subclass__(cls, **kwargs):            super().__init_subclass__(**kwargs)            cls.subclasses.append(cls)    class Plugin1(PluginBase):        pass    class Plugin2(PluginBase):        pass

为了允许零参数
super（）
从
_init_subclass __（）
实现中被正确的调用并工作，自定义元类必须确保新的__classcell__命名空间输入传递到type .__ new__（如
创建类对象
)
参见
PEP 487
 - 用于建立类的更简单的自定义
由Martin Teichmann撰写并实现的PEP。

功能文档
PEP 487: 描述符协议增强
PEP 487
 扩展描述符协议必须包括新的可选的
__set_name __（）
方法。 每当定义一个新类时，新方法将会调用定义中所有的描述符，并给它们提供定义类的引用，以及类命名空间中给予描述符的名字。 换句话说，描述符的实例现在可以获知所有者类的属性名：
    class IntField:        def __get__(self, instance, owner):            return instance.__dict__[self.name]        def __set__(self, instance, value):            if not isinstance(value, int):                raise ValueError(f'expecting integer in {self.name}')            instance.__dict__[self.name] = value        # this is the new initializer:        def __set_name__(self, owner, name):            self.name = name    class Model:        int_field = IntField()

参见
PEP 487
 - 用于建立类的更简单的自定义
由Yury Selivanov撰写并实现的PEP。

功能文档
PEP 519: 添加文件系统路径协议
文件系统路径过去被表示为
str
或
bytes
对象。这会导致那些编写操作文件系统路径代码的人，假定这些对象只能是这两种类型之一(一个代表着文件描述符的
int
对象将不被计入即它不是一个文件路径)。 
不幸的是，这种假设局限了文件系统路径表示代方法，如已经存在的
pathlib
，同时也包括python的一些标准库。 
为了解决这种情况，定义了一个由
os.PathLike
表示的新接口。通过实现
__fspath__()
方法，一个对象表示一个路径，然后，可以将文件系统路径表示为一个较低等级的
str
或者
bytes
对象。这意味着，如果一个对象实现
os.PathLike
或者是
str
或
bytes
，该对象被认为是
path-like
,它代表一个文件系统路径。你可以使用
os.fspath()
,
os.fsdecode()
或
os.fsencode()
显式获取
str
以及/或
bytes
来表示一个path-like对象。 
内建函数
open()
已经更新，可以接受
os.PathLike
对象，以及在
os
和
os.path
模块中的所有函数，以及标准库中的大多数其他函数和类。类
os.DirEntry
以及
pathlib
中相关的类也已经可以实现
os.PathLike
。 
希望对操作文件系统路径基本功能的更新能够让第三方代码在不改变任何代码，或者至少是非常少的代码（例如，在操作path-like对象之前，在代码的开头调用
os.fspath()
）的情况下，能够隐含地支持所有
path-like objects
对象。 
下面举一些例子说明新接口是如何让预先存在的代码简单透明地使用
pathlib.Path
:
    >>> import pathlib    >>> with open(pathlib.Path("README")) as f:    ...     contents = f.read()    ...    >>> import os.path    >>> os.path.splitext(pathlib.Path("some_file.txt"))    ('some_file', '.txt')    >>> os.path.join("/a/b", pathlib.Path("c"))    '/a/b/c'    >>> import os    >>> os.fspath(pathlib.Path("some_file.txt"))    'some_file.txt'

（由Brett Cannon, Ethan Furman, Dusty Phillips, and Jelle Zijlstra实现）
参见
PEP 519
 - 添加文件系统路径协议
PEP 由Brett Cannon 和 Koos Zevenhoven撰写.

PEP 495: 本地时间消歧
世界上大多数地方，都曾经出现也将出现多次的时间回调。在这种时候，引入时间间隔用以表示本地时钟在同一天中出现两次相同的时间的情况，在这些情况下，本地时钟显示的时间（或存在在python datetime中的实例）不足及时表示特定的时刻。 
为了区分本地时间相同的两个时刻，
PEP 495
 在类
datetime.datetime
 和 
`datetime.time`
 的实例中增加了新的fold属性:
    >>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)    >>> for i in range(4):    ...     u = u0 + i*HOUR    ...     t = u.astimezone(Eastern)    ...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)    ...    04:00:00 UTC = 00:00:00 EDT 0    05:00:00 UTC = 01:00:00 EDT 0    06:00:00 UTC = 01:00:00 EST 1    07:00:00 UTC = 02:00:00 EST 0

属性 
fold
 的值除了表示不明确情况下的第二（时间顺序）时刻之外，其他所有实例的值都为 0。 
又见
PEP 495
 - 本地时间消歧
PEP 由 Alexander Belopolsky 和 Tim Peters撰写, 由Alexander Belopolsky实现.

PEP 529: 更改windows下文件系统编码格式为UTF-8
使用str (Unicode) 表示文件系统路径比bytes能获得更好的效果。尽管如此，在某些情况下bytes也足以胜任并且也是正确的。
在3.6之前,使用bytes路径可能导致数据丢失。改进后, windows下现在支持使用bytes表示路径,这些bytes将以
sys.getfilesy stemencoding()
的方式编码，默认编码格式为'utf-8'。
不使用str方式表示路径的应用程序应当使用
os.fsencode()
和
os.fsdecode()
 以确保他们的bytes被正确编码。要回复到之前的状态, 设置 
PYTHONLEGACYWINDOWSFSENCODING
 或者调用
sys._enablelegacywindowsfsencoding()
。
查看 
PEP 529
以获取更多信息并讨论可能需要变更的代码。
PEP 528: 更改windows控制台编码为UTF-8
windows下的默认控制台现在支持所有的Unicode字符并可以正确读取Python代码中的str对象。 sys.stdin, sys.stdout 
以及 sys.stderr 现在的默认使用utf-8编码。
这一变化仅适用于使用交互控制台之时，而非重定向文件或者管道。如果要使用之前的交互控制台, 需设置
PYTHONLEGACYWINDOWSIOENCODING
。
另请参阅
PEP 528
 - 修改windows控制台编码为UTF-8
PEP 由Steve Dower编写和实现。

PEP 520: 保存类属性定义顺序
类的定义体中的属性有一个自然顺序：即源码中属性名出现的顺序。 这个顺序现在保存在新的类
__dict__
 的属性中.
同样， 有效的缺省类和执行空间 (从
type.prepare()
返回)是一个保存插入顺序的映射。
另请参阅
PEP 520
 - 保存类属性定义顺序
该PEP由Eric Snow编写和实现。

PEP 468: 保存关键字参数顺序
函数声明中的**kwargs 的顺序现在被保证是插入顺序的映射。
另请参阅
PEP 468
 - 保存关键字参数顺序
该PEP由Eric Snow编写和实现。

新的 
字典dict
类型的实现
字典dict
类型现在使用 
PyPy首创
的 "紧凑" 表达方式。 新
字典dict()
 的内存占用比Python3.5中减少20%到25%。
新的实现中保存顺序的功能被认为是不可过于依赖的(未来也许会改变，不过在将所有当前和未来的Python实现的语言规范转换为保证顺序的语法之前的几个版本中，新的dict有望被实现的; 这也能帮助保证对那些仍旧是随机迭代顺序的旧版本的向后兼容，比如Python 3.5)。
(由INADA Naoki在
issue 27350
提供。 想法 
最初由Raymond Hettinger提出
.)
PEP 523：添加一个frame解析API到CPython
虽然Python提供了自定义代码执行方式的广泛支持，但是还有一个它没这样做的地方是frame对象的解析。如果你想要通过某些方式在Python中拦截frame解析，那么除了直接对定义的函数操作函数指针之外，真的没有什么其他方式。
PEP 523
改变了这个处境，它提供了一个API，让frame解析在C层次上可插拔。这将允许诸如调试器或者JIT这样的工具在Python代码开始执行之前拦截frame解析。这使得python代码的可替换解析实现、跟踪frame解析等地使用成为可能。
这个API并不是受限的C API的一部分，并且被标为私有，表示期望限制这个API的使用，并且只能应用在非常选定的低层次用例上。这个API的语义将在必要的时候随着Python改动。
又见
PEP 523
 - 添加一个frame解析API到CPython
PEP由Brett Cannon和Dino Viehland编写

PYTHONMALLOC环境变量
新的
PYTHONMALLOC
环境变量允许设置Python内存分配器和安装调试钩子。
现在有可能在发布模式下使用PYTHONMALLOC=debug编译的Python中，在Python内存分配器上安装调试钩子。调试钩子的效果：
新分配内存由字节0xCB填充
被释放内存由字节0xDB填充
检测Python内存分配器API的违规。例如，在由
PyMem_Malloc()
分配的内存块上调用PyObject_Free()。
检测缓存开始位置之前的写入 (缓存下溢)
检测缓存结束位置之后的写入 (缓存上溢)
当调用了
PYMEM_DOMAIN_OBJ
 (例如，PyObject_Malloc())和
PYMEM_DOMAIN_MEM
 (例如，
PyMem_Malloc()
)域的分配器函数时，检测持有
GIL
。
检测是否持有GIL也是Python 3.6的一个新特性。
见
PyMem_SetupDebugHooks()
函数，了解更多关于Python内存分配器上的调试钩子信息。
现在也有可能使用PYTHONMALLOC=malloc，从而强制所有Python内存分配使用C库的malloc()分配器。这在以发布模式编译的Python上，使用诸如Valgrind这样的外部内存调试器是有帮助的。
对于错误，Python内存分配器上的调试钩子现在使用
tracemalloc
模块来获取分配内存块的地址的回溯信息。
使用python3.6 -X tracemalloc=5 (存储5个帧到回溯中)时，在缓存上溢时的致命错误的例子：
    Debug memory block at address p=0x7fbcd41666f8: API 'o'        4 bytes originally requested        The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.        The 8 pad bytes at tail=0x7fbcd41666fc are not all FORBIDDENBYTE (0xfb):            at tail+0: 0x02 *** OUCH            at tail+1: 0xfb            at tail+2: 0xfb            at tail+3: 0xfb            at tail+4: 0xfb            at tail+5: 0xfb            at tail+6: 0xfb            at tail+7: 0xfb        The block was made by call #1233329 to debug malloc/realloc.        Data at p: 1a 2b 30 00    Memory block allocated at (most recent call first):      File "test/test_bytes.py", line 323      File "unittest/case.py", line 600      File "unittest/case.py", line 648      File "unittest/suite.py", line 122      File "unittest/suite.py", line 84    Fatal Python error: bad trailing pad byte    Current thread 0x00007fbcdbd32700 (most recent call first):      File "test/test_bytes.py", line 323 in test_hex      File "unittest/case.py", line 600 in run      File "unittest/case.py", line 648 in __call__      File "unittest/suite.py", line 122 in run      File "unittest/suite.py", line 84 in __call__      File "unittest/suite.py", line 122 in run      File "unittest/suite.py", line 84 in __call__      ...

(由Victor Stinner于
issue 26516
和
issue 26564
贡献。)
DTrace和SystemTap探测支持
Python现在可以使用--with-dtrace来构建，它为解释器中的以下事件启用了静态标志器：
函数调用／返回
垃圾回收开始/结束
执行代码行。
这可以被用来检测生产中运行的解释器，而无需重新编译指定调试构建，或者提供应用特有的配置/调试代码。
详情请见
用DTrace和SystemTap检测CPython
。
在Linux和macOS上测试了当前实现。未来可能会添加额外的标志器。
(由Łukasz Langa在
issue 21590
中贡献，基于Cea Avión, David Malcolm, 和Nikhil Benesch提供的补丁)
其他语言方面的变化
我们还对 Python 语言的核心做了一些小的改变：
现在在同一作用域内的 global 或 nonlocal 语句必须在受其影响的命名使用前显式出现。在先前版本中会发出语法警告。
现在能以将 
魔术方法
 设置为 None 的方式来表示相应的操作不可用。 例如，如果将一个类的 
__iter__()
 设置为None，则该类不可迭代。(由 Andrew Barnert 和 Ivan Levkivskyi 在
issue 25958
 中贡献。)
在 traceback 中大量重复出现的 traceback lines 将会被略写成 "[前一行已经重复出现 {count} 次了]" (以 traceback 为例。). (由 Emanuel Barry 在 
issue 26823
 中贡献。)
现在模块导入在找不到模块时引发新的异常
ModuleNotFoundError
（
ImportError
 的子类）。 当前检测 ImportError 的代码（try-except中）仍然可以工作。(由 Eric Snow 在 
issue 15767
 中贡献。)
在类创建时，被元类调用的依赖无参数的 super() 的类方法时会正确工作。(由 Martin Teichmann 在 
issue 23722
中贡献。)
新增模块
secrets
新增模块 
secrets
 的主要目的是：提供一个显式可靠的方式来产生适合于管理诸如账户认证，令牌之类的保密信息的加密的强伪随机值。
警告
注意在 
random
模块中的随机数生成器 不该 用于安全目的。Python 3.6 及以上版本请使用 
secrets
 而 Python 3.5 及更早的版本请使用 
os.urandom()
。
又见
PEP 506
 - 向标准库添加 Secrets 模块
PEP 由 Steven D'Aprano 编写及实现。

改进模块
array
耗尽的迭代器
array.array
现在将会保持被耗尽，即使被迭代的数组被拓展了。这与其他可变序列的行为保持了一致性。
由Serhiy Storchaka在
issue 26492
中贡献
ast
添加了新的ast.Constant的AST节点。它可以被外部的AST优化器出于永久聚合(constant foldind)。
由Victor Stinner在
issue 26146
中贡献
asyncio
始于Python 3.6，asyncio模块将不再是临时的了，并且它的API被认为是稳定的。
从Python 3.5开始，在asyncio模块中值得注意的变化（由于临时的状态，所有的修改都应用到了3.5.x）:
get_event_loop()
函数已经被改变为，当从协同程序中调用和被回调调用时，总是返回当前正在运行的循环。（由 Yury Selivanovgong贡献于
issue 28613
。）
ensure_future()
函数和所有使用其的函数，比如loop.run_until_complete()，现在接收所有种类的
awaitable objects
。（由 Yury Selivanov贡献）。
新的
run_coroutine_threadsafe()
函数去从其他线程中提交协同程序到事件循环中。（由Vincent Michel贡献）
新的
Transport.is_closing()
方法去检查是否传输是关闭的或被关闭了（由Yury Selivanov贡献）。
loop.creat_server()现在可以以列表接收主机了。（由Yann Sionneaugong贡献）
新的loop.creat_future()方法去创建一个Future对象。这允许了替代事件循环的实现，比如
uvloop
，去提供了一种更快的
asyncio.Future
的实现。（由Yury Selivanov在
issue 27041
中贡献）
新的loop.get_exception_handler()方法去得到一个当时的异常的句柄。（由Yury Selivanov在
issue 27040
中贡献）
新的
StreamReader.readuntil()
方法从流中读取数据读取数据直到出现分隔符字符序列。（由Mark Korenberg贡献）
StreamReader.readexactly()
的表现被提升了。（由Mark Korenberg在
issue 28370
中贡献）
loop.getaddrinfo()方法被优化了，避免了如果地址问题已经解决，去调用系统函数getaddrinfo。（由A. Jesse Jiryu Davis贡献）
loop.stop()方法已经被更改，以便在当前迭代后立即停止循环。任何新的，作为最后一次迭代的结果的预定的回调将会被丢弃。（由Guido van Rossum在
issue 25593
中贡献）
Future.set_exception在通过了一个
StopIteration
实例的异常后，将会引发
TypeError
。（由Chris Angelico在
issue 26221
贡献）
新的
loop.connect_accepted_socket()
方法被服务器用来接收asyncio外部的连接，但是使用asyncio去处理。（由Jim Fulton在
issue 27392
中贡献）
TCP_NODELAY标志位现在被默认设置为TCP传输。（由Yury Selivanov在
issue 27456
中贡献）
新的
loop.shutdown_asyncgens()
在关闭循环之前恰当的关闭挂起的异步生成器。（由 Yury Selivanov在
issue 28003
中贡献）
Future
和
Task
类现在有一个已优化的C语言的实现，使得asyncio编码速度提高了30%。（由Yury Selivanov和INADA Naoki在
issue 26081
和
issue 28544
中贡献）
binascii
b2a_base64()
功能现在接收现在接收一个可选
newline
的关键词参数去控制是否新的一行的字符被加到返回值中。（由Victor Stinnergong贡献于
issue25357
。）
cmath
新增了方法 
cmath.tau
 来表示(τ) 常量. (由Lisa Roach在
issue 12345
中贡献, 详情请查看 
**PEP628**
 .)
新增的常量还有: 
cmath.inf
 和
cmath.nan
 来对应
math.inf
 和
math.nan
, 另外还有
cmath.infj
 和
cmath.nanj
来匹配复数表达式的格式化. (由MarkDickinson在
issue 23229
中贡献.)
collections
新的
Collection
抽象基类已经增加到可表示大小的迭代器类里面 
(由Ivan Levkivskyi贡献, 文档由Neil Girdhar在
issue 27598
中贡献.)
新的
Reversible
 有迭代器类的抽象基类 
__reversed__()
 方法. (由Ivan Levkivskyi在
issue25987
中贡献.)
新的 
AsyncGenerator
，是一种异步生成器类的抽象基类. (Contributed by Yury Selivanov in 
issue 28720
.)
这个
namedtuple()
函数现在接受一个可选的关键字参数 
module
,它指定用于__module__返回的命名元组类的属性. (由Raymond Hettinger在
issue 17941
中贡献.
namedtuple()
的
verbose
 和 
rename
参数是强制关键字参数. (由Raymond Hettinger 在
issue 25628
中贡献.)
递归方法
collections.deque
 实例现在可使用pickle持久化存储. 
(由Serhiy Storchaka在
issue26482
中贡献.)
concurrent.futures¶
ThreadPoolExecutor
 类的构造函数现在接受一个可选的
thread_name_prefix
 参数，使自定义线程池中的线程名字成为可能 (由Gregory P. Smith 贡献在
issue 27664
.)
contextlib¶
contextlib.AbstractContextManager
 类已经成为上下文管理器中的一个抽象基类 
。它提供了一个合理的默认返回self的 enter()方法，和一个exit()抽象方法. 一个匹配的类
`typing.ContextManager`
.被添加到
typing
。 (由 Brett Cannon 贡献在
issue25609
.)
datetime
decimal
distutils
email
encodings
enum
faulthandler
在Windows平台,
faulthandler
模块安装了一个指示Windows异常的句柄 : 详情可见于 [faulthandler.enable()](
https://docs.p
http://
ython.org/3.6/library/f
aulthandler.html#faulthandler.enable
"faulthandler.enable" ). (由 Victor Stinner 在 
issue23848
中贡献.)
fileinput
hook_encoded()
 模块现在可支持errors参数. 
(由 Joseph Hackman 在 
issue25788
贡献.)
hashlib
hashlib
 支持 OpenSSL 1.1.0。推荐使用的最低版本为1.0.2. (由Christian Heimes 在
issue 26470
贡献.)
BLAKE2 hash 函数也被收录进这一模块. 
blake2b()
 与
blake2s()
 将长期支持BLAKE2的所有特性. (由Christian Heimes依据Dmitry Chestnykh 和 Samuel Neves的代码在
issue 26798
 贡献. 文档由Dmitry Chestnykh撰写.)
新增SHA-3哈希函数sha3_224(),sha3_256(),sha3_384(),sha3_512(), 与SHAKE 哈希函数 shake_128() 、shake_256() . (由Christian Heimes 在 
issue16113
贡献. Keccak 代码包由Guido Bertoni, Joan Daemen, Michaël Peeters, Gilles Van Assche, and Ronny Van Keer撰写.)
基于密码的密钥导出函数
scrypt()
 可使用 OpenSSL 1.1.0 或更新版本. (由Christian Heimes 在 
issue 27928
中贡献.)
http.client
HTTPConnection.request()
and
endheaders()
将全部支持分块编码请求体. (由Demian Brecht and Rolf Krahl 在 
issue 12319
中贡献.)
idlelib and IDLE
对idle包做了现代化的改进与重构，使得IDLE更美观、更好用的同时令编程更易于理解、测试与改进。在IDLE的美化方面，特备针对Linux和Mac用户，我们在大多数对话框上应用了ttk插件。总之，IDLE将不再支持tcl/tk 8.4。现在要求有 tcl/tk 8.5 或 8.6。我们建议在使用时运行最新的版本.
“现代化”包括对idlelib模块的重命名和整合.重命名文件部分大写的名字是与之前版本类似的命名，例如，Tkinter和TkFont对应3.0版本中的Tkinter和tkinter.font 。因此，对idlelib在3.5环境下导入的文件通常不会工作在3.6。至少一个模块的名称需要改变（见idlelib / readme.txt），有时甚至会更多。(名称变更由Al Swiegart 与 Terry Reedy 在 
issue 24225
中贡献. 大多数idle补丁均会加入这一改进。)
做点补充，最终的结果是，一些idlelib类会更容易使用，将具有更好的API文档与字符串的解释。其他有用的信息会在可用时被及时添加到idlelib。
importlib
当无法找到被导入模块时会跳出一个新的异常提示
ModuleNotFoundError
(
ImportError
的一个子类)。检测ImportError的代码（try-except）依然会工作。 (由 Eric Snow在
issue15767
中贡献.)
importlib.util.LazyLoader
在打包好的装载器上更名为
`create_module()`
 , 去除了
importlib.machinery.BuiltinImporter
与
`importlib.machinery.ExtensionFileLoader`
不能同 
importlib.util.LazyLoader
一起使用的限制.
importlib.util.cache_from_source()
,
importlib.util.source_from_cache()
, 和
importlib.util.spec_from_file_location()
 现在可接受
path-likeobject
.
inspect
inspect.signature()
函数现在支持报告由编译器为推导式和生成器表达式范围生成的隐式.0参数，就好像它们是名为implicit0的仅位置参数。 (由Jelle Zijlstra在
issue 19611
中贡献。)
为了减少从Python2.7和旧版
`inspect.getargspec()`
 API升级时的代码改动，先前记录的对
`inspect.getfullargspec()`
对弃用已经撤销。虽然这个函数对于单个/源Python2/3代码库是很方便的，但是更丰富的
`inspect.signature()`
接口仍然是新代码的推荐方法。(由Nick Coghlan在
issue27172
中贡献)
json
json.load()
和
json.loads()
现在支持二进制输入。已编码的JSON应该用UTF-8, UTF-16, 或者UTF-32来表示。(由Serhiy Storchaka在
issue 17909
中贡献。)
logging
已添加新的
WatchedFileHandler.reopenIfNeeded()
方法来增加检查日志文件是否需要被重新打开的能力。(由Marian Horban在
issue 24884
中贡献。)
math
已添加tau (τ)常量到
math
和
cmath
模块中。(由Lisa Roach在
issue 12345
中贡献，见
**PEP 628**
以了解详情。)
multiprocessing
multiprocessing.Manager()返回的
Proxy对象
现在可以被嵌套。(由Davin Potts在
issue6766
中贡献。)
os
见
PEP 519
的摘要，以获取关于
os
和
os.path
模块现在如何支持
类路径（path-like）对象
的详情。
scandir()
现在支持Windows上的
bytes
路径。
一个新的
close()
方法允许显式关闭一个
scandir()
迭代器。
scandir()
迭代器现在支持
上下文管理器
协议。如果一个scandir()迭代器既不是被耗尽，也不是被显式关闭，那么在其析构函数中将会抛出一个
ResourceWarning
。(由Serhiy Storchaka在
issue 25994
中贡献。)
在Linux上，
os.urandom()
现在会阻塞，直到系统的urandom entropy池被初始化，以提高安全性。见
**PEP 524**
以了解缘由。
Linux的getrandom()系统调用(获取随机字节)现在作为新的
os.getrandom()
函数公开。(由Victor Stinner贡献，属于
**PEP 524**
部分)
pathlib
pathlib
现在支持
类路径（path-like）对象
。 
(由Brett Cannon在
issue 27186
中贡献。)
见PEP 519的摘要了解详情。
pdb
Pdb
类构造器有一个新的可选
readrc
参数，用来控制是否应该读取.pdbrc文件。
pickle
对象，现在可以使用关键参数 __new__进行持久存储
pickle协议
超过已有的协议版本4.支持这种情况. (由Serhiy Storchaka在
issue24164
的贡献。)
pickletools
现在[pickletools.dis()](
32.13. pickletools - Tools for pickle developers - Python 3.6.0 documentation
kletools.dis "pickletools.dis" )输出的隐含备注是MEMOIZE操作码的索引。 (由Serhiy Storchaka在
issue25382
的贡献。)
pydoc
pydoc
模块已经学会遵守MANPAGER环境变量。 (由Matthias Klose在
issue 8637
的贡献。)
help()
和 
pydoc
 现在能用指定的元组字段定义的顺序来显示列表，而不是按字母顺序。(由Raymond Hettinger在
issue24879
的贡献。)
random
这个新
choices()
函数返回一个指定元素大小的列表，通过可选权重给出它的规模。(由Raymond Hettinger在
issue 18844
的贡献。)
re
在正则表达式中，增加对 spans 修饰符的支持。 示例: 
'(?i:p)ython' 匹配 'python' 和 'Python', 但不匹配'PYTHON'；'(?i)g(?-i:v)r' 匹配 'GvR' 和 'gvr', 但不匹配'GVR'。(由Serhiy Storchaka在 
issue 433028
 的贡献。)
匹配对象组可通过 __getitem__访问, 它就等价于 group()。因此， 现在mo['name'] 就等价于 mo.group('name')。(由 Eric Smith 在
issue 24454
的贡献。)
现在，Match 对象支持 
index-like objects
 一样的组索引。 (由Jeroen Demeyer and Xiang Zhang在
issue27177
的贡献。)
readline
增加了 
set_auto_history()
启用或停用自动把输入加到历史列表中。 (由Tyler Crompton在
issue26870
的贡献。)
rlcompleter
现在，除非前缀开始使用下划线，否则私有和特殊属性名称就被忽略。在一些完成的关键字后面添加一个空格或冒号。 
(由Serhiy Storchaka在
issue25011
 和 
issue25209
的贡献。)
shlex
shlex
 已经大大 
改进shell的兼容性
 ,通过新的
punctuation_chars
 参数来控制，哪些字符被作为标点符号。 (由Vinay Sajip 在
issue1521950
的贡献。)
site
在一个.pth文件里，当指定路径添加到
sys.path
中,可能你现在要在目录之上指定文件路径 (例如：zip文件)。 (由Wolfgang Langner 在
issue26587
的贡献)。
sqlite3
sqlite3.Cursor.lastrowid
 现在支持REPLACE 声明. (贡献者： Alex LordThorsen 于 
issue16864
.)
socket
ioctl()
函数现在支持
`SIO_LOOPBACK_FAST_PATH`
 控制代码. (贡献者： Daniel Stokes 于 
issue 26536
.)
getsockopt()
 常量 SO_DOMAIN, 
SO_PROTOCOL, SO_PEERSEC, 和 SO_PASSSEC 现已被支持. (贡献者：Christian Heimes 于
issue 26907
.)
setsockopt()
现在支持setsockopt(level, optname, None, optlen: int) 形式. (贡献者：Christian Heimes 于 
issue 27744
.)
socket 模块现在支持地址族
AF_ALG
 来和Linux Kernel crypto API连接. 添加了ALG_*,SOL_ALG 和 
sendmsg_afalg()
.(贡献者： Christian Heimes 于 
issue27744
 在Victor Stinner帮助下完成.)
socketserver
基于 
socketserver
 模块,包括了
http.server
,
xmlrpc.server
和
wsgiref.simple_server
的Servers 现在支持 
contextmanager
protocol. (Contributed by Aviv Palivoda in 
issue26404
.)
StreamRequestHandler
 类的 wfile 属性 现在实现 the
`io.BufferedIOBase`
 可写接口. 特别地, 调用 
write()
 现在可以保证完全发送数据. 
(贡献者： Martin Panter于
issue26721
.)
ssl
ssl
 已支持 OpenSSL 1.1.0. 最低推荐版本号是 1.0.2. (贡献者： Christian Heimes 于 
issue26470
.)
3DES 已从默认密码套件default cipher suites中删除添加了密码套件ChaCha20 Poly1305. (贡献者： Christian Heimes 于
issue27850
 和 
issue27766
.)
SSLContext
 有更好的默认配置选项和密码.(贡献者： Christian Heimes 于 
issue28043
.)
SSL session 可以使用新的 
SSLSession
 类从一个客户端连接复制到另一个客户端连接.TLS会话恢复可以加速初始握手，减少延迟并提高性能 (贡献者： Christian Heimes 于
issue19500
 ，基于Alex Warhawk的草案.)
新的 
get_ciphers()
方法可以用来得到一个按密码优先级顺序的已启用密码列表.
所有的 constants and flags已转换为
IntEnum
 和 IntFlags. (贡献者 ：Christian Heimes于
issue28025
.)
Server 和 client-side添加
SSLContext
 特定 TLS 协议. (贡献者： Christian Heimes 于 
issue28085
.)
statistics
已添加一个新的
harmonic_mean()
函数。 (由Steven D'Aprano在
issue 27181
中贡献。)
struct
通过'e'格式限定符，
struct
现在支持IEEE 754半精度浮点。(由Eli Stevens, Mark Dickinson在
issue 11734
中贡献。)
subprocess
当子系统仍然运行着的时候，
subprocess.Popen
析构函数现在发出一个
ResourceWarning
警告。使用上下文管理器协议(with proc: ...)或者明确调用
wait()
方法来读取子进程的退出状态。 
(由Victor Stinner在
issue 26741
中贡献。)
subprocess.Popen
构造函数和所有传给它的函数现在接受
encoding
和
errors
参数。指定其中一个将会为
stdin
, 
stdout
和
stderr
流启用文本模式。(由Steve Dower在
issue 6135
中贡献。)
sys
新的
getfilesystemencodeerrors()
函数返回用来在Unicode文件名和字节文件名之间转换的错误模式的名字。(由Steve Dower在
issue 27781
中贡献。)
在Windows上，
getwindowsversion()
函数的返回值现在包含了
platform_version
字段，它包含当前操作系统准确的最大版本、最小版本和构建版本，而不是模拟进程的版本 (由Steve Dower在
issue 27932
中贡献。)
telnetlib
Telnet
现在是一个上下文管理器了 (由Stéphane Wirtel在
issue 25485
中贡献)。
time
struct_time
的属性tm_gmtoff和tm_zone现在在所有平台上都可用了。
timeit
已添加新的
Timer.autorange()
便捷方法来反复调用
Timer.timeit()
，以便总运行时间大于或等于200毫秒(由Steven D'Aprano在
issue 6422
中贡献。)
当在最佳和最差时间之间存在一个很大（4x）的差时，
timeit
现在会告警。(由Serhiy Storchaka在
issue 23552
中贡献。)
tkinter
在tkinter.Variable类中添加了方法trace_add（），trace_remove（）和trace_info（）。它们代替了之前版本中的trace_variable（），trace（），trace_vdelete（）和trace_vinfo（）方法，这些方法使用过时的Tcl命令，而在未来版本的Tcl中，这些Tcl命令可能不起作用。（由Serhiy Storchaka在
issue22115
 提供）。
traceback
traceback模块和解释器内置的异常展示现在都省略回溯中重复行的长串，如以下例子所示：
    >>> def f(): f()    ...    >>> f()    Traceback (most recent call last):      File "<stdin>", line 1, in <module>      File "<stdin>", line 1, in f      File "<stdin>", line 1, in f      File "<stdin>", line 1, in f      [Previous line repeated 995 more times]    RecursionError: maximum recursion depth exceeded

(由Emanuel Barry在
issue 26823
中贡献。)
tracemalloc
tracemalloc
模块限制支持跟踪多个不同地址空间内的内存分配。
已添加新的
DomainFilter
过滤器类来根据地址空间（域）过滤块跟踪。
(由Victor Stinner在
issue 26588
中贡献。)
typing
从Python 3.6起，
typing
模块不再是临时的了，可以把它的API当成稳定版本使用。
由于
typing
模块在Python 3.5中是
临时的
，因此Python 3.6中引入的所有变动也已向后移植到Python 3.5.x。
typing
模块很大提高了对范型别名的支持。例如，Dict[str,Tuple[S,T]]现在是一个有效的类型注释了。(由Guido van Rossum在
Github#195
中贡献。)
已添加
typing.ContextManager
类来展示
contextlib.AbstractContextManager
。(由Brett Cannon在
issue25609
中贡献。)
已添加
typing.Collection
类来展示
collections.abc.Collection
。 (由Ivan Levkivskyi在
issue27598
中贡献。)
已添加
typing.ClassVar
类型构造，来标识类变量。如
**PEP 526**
中所述，封装在ClassVar中的一个变量注解暗示着一个给定的属性打算作为一个类变量使用，并且不应该在那个类的实例上设置它。(由Ivan Levkivskyi在
Github#280
中贡献。)
一个新的
TYPE_CHECKING
常量被静态类型检查器假设为True，但在运行时则为False。 (由Guido van Rossum在
Github#230
中贡献。)
已添加一个新的
NewType()
辅助函数来为注释创建轻量单值类型：
    from typing import NewType    UserId = NewType('UserId', int)    some_id = UserId(524313)

静态类型检查器将会把新的类型当成原始类型的一个子类。 (由Ivan Levkivskyi在
Github #189
中贡献。)
unicodedata
unicodedata
模块现在使用来自
Unicode 9.0.0
的数据。 
(由Benjamin Peterson贡献)
unittest.mock
Mock
类有以下改进：
两个新的方法，
Mock.assert_called()
和
Mock.assert_called_once()
，用来检测是否调用了mock对象。(由Amit Saha在
issue 26323
中贡献。)
Mock.reset_mock()
方法现在拥有两个可选的仅关键字参数：
return_value
 和 
side_effect
。 (由Kushal Das在
issue 21271
中贡献。)
urllib.request
如果一个HTTP请求具有一个文件或者可迭代请求体 (不同于一个bytes对象)，但是没有Content-Length头，那么现在AbstractHTTPHandler会回退到使用分块传输编码，而不是抛出一个错误。 
(由Demian Brecht和Rolf Krahl在
issue 12319
中贡献。)
urllib.robotparser
RobotFileParser
现在支持Crawl-delay和Request-rate扩展。(由Nikolay Bogoychev在
issue 16099
中贡献。)
venv
venv
接受一个新的参数--prompt。这个参数为虚拟环境提供一个可替换的前缀。(在
issue22829
中，由Łukasz Balcerzak提出，并由Stéphane Wirtel移植到3.6。)
warnings
增加一个可选参数到
warnings.warn_explicit（）
函数中：引发
ResourceWarning
的已销毁对象。 同时，属性也添加到warnings.WarningMessage 中。（由Victor Stinner在
issue26568
和
issue26567
中提供）。
当引发
 ResourceWarning 
警告时，
tracemalloc
 模块就尝试检索分配了销毁对象的跟踪。
一个名为 example.py的例子
    import warnings    def func():        return open(__file__)    f = func()    f = None

输出命令 python3.6 -Wd -X tracemalloc=5 example.py :
    example.py:7: ResourceWarning: unclosed file <_io.TextIOWrapper name='example.py' mode='r' encoding='UTF-8'>      f = None    Object allocated at (most recent call first):      File "example.py", lineno 4          return open(__file__)      File "example.py", lineno 6          f = func()

“对象分配”跟踪是新的，并且只有当
tracemalloc
正在跟踪Python内存分配，并且
 warnings
 模块已经导入时才会显示。
winreg
新增64位整数类型
REG_QWORD
. (Contributed by Clement Rouault in 
issue23026
.)
winsound
允许传递关键词参数到
Beep
,
MessageBeep
, 和
PlaySound
 方法。 (
issue 27982
).
xmlrpc.client
xmlrpc.client
 模块现支持解压由apache XML-RPC实现用于数字和'None'的附加数据类型。(Contributed by Serhiy Storchaka in
issue 26885
.)
zipfile
一个新的类方法
ZipInfo.from_file()
 允许从文件系统文件中生成一个
ZipInfo
 实例。 
一个新的方法 
ZipInfo.is_dir()
 能够用来检查
ZipInfo
 实例是否表示一个目录。 (Contributed by Thomas Kluyver in 
issue 26039
.)
ZipFile.open()
 方法现在能够将数据写入到一个ZIP文件，也能够从中提取数据。 (Contributed by Thomas Kluyver in 
issue 26039
.)
zlib
compress()
 以及
decompress()
 函数现接受关键词参数。 (Contributed by Aviv Palivoda in 
issue 26243
 and Xiang Zhang in 
issue16764
 respectively.)
优化
Python解释器现在使用16位编码而不是字节码，这使得你可以实现多种操作码的优化。(由Demur Rumed，Serhiy Storchaka和Victor Stinner在
issue 26647
 以及 
issue 28050
中贡献。)
asyncio.Future
类现在有一种优化的C实现。(由Yury Selivanov和INADA Naoki在
issue 26081
中贡献。)
asyncio.Task
类现在有一种优化的C实现。(由Yury Selivanov在
issue 28544
中贡献。)
在
typing
模块中通过各种改进的实施(如泛型类型的缓存)，使得其允许高达30倍的性能优化，并且减少了内存占用。
ASCII解码器的错误处理程序 surrogateescape, ignore 以及replace 速度提高了60倍。(由Victor Stinner在
issue 24870
中贡献)。
ASCII和Latin1解码器的错误处理程序 surrogateescape 速度提高了3倍。(由Victor Stinner在
issue 25227
中贡献)。
UTF-8解码器的错误处理程序 ignore, replace,surrogateescape, surrogatepass速度提高了75倍。(由Victor Stinner在
issue 25267
中贡献)。
UTF-8解码器的错误处理程序ignore, replace andsurrogateescape速度提高了15倍。由Victor Stinner在
issue 25301
中贡献)。
bytes % args现在速度可以提高到2倍。(由Victor Stinner在
issue 25349
中贡献)。
bytearray % args 现在速度是以前的2.5到5倍。(由Victor Stinner在
issue 25399
中贡献)。
对
bytes.fromhex()
和
bytearray.fromhex()
进行优化:现在比以前快2x到3.5x倍。(由Victor Stinner在
issue 25401
中贡献)。
对bytes.replace(b'', b'.')和bytearray.replace(b'', b'.')进行优化:速度可提高80%。 (由Josh Snider在
issue 26574
中贡献)。
现在
PyMem_Malloc()
域(
PYMEM_DOMAIN_MEM
)的分配函数使用
pymalloc memory allocator
，而不是C库中的malloc()函数。 pymalloc分配器针对大小小于等于512字节、生命周期较短的对象进行了优化，而当需要占用较大内存块时则使用malloc()。 (由Victor Stinner在
issue 26249
中贡献)。
当对大量小对象进行反序列化时，
pickle.load()
和
pickle.loads()
的速度可提高10%。(由Victor Stinner在
issue 27056
中贡献)。
与传递
位置参数
相比，将
关键字参数
传递给函数会带来额外的开销。 现在在通过使用Argument Clinic实现的扩展功能中，这种开销将会显著的降低。(由Serhiy Storchaka在
issue 27574
中贡献)。
对
glob
模块中的
glob()
及
iglob()
进行优化;使得它们现在大概快了3-6倍。(由Serhiy Storchaka在
issue 25596
中贡献)。
使用
os.scandir()
对
pathlib
中的glob进行优化;使它大概快了1.5-4倍。(由Serhiy Storchaka在
issue 26032
中贡献)。
xml.etree.ElementTree
中解析、迭代和深拷贝的性能有了显著的提高。 (由Serhiy Storchaka在
issue 25638
、
issue 25873
及
issue 25869
中贡献。)
由浮点数和小数创建
fractions.Fraction
实例的速度提高了2到3倍。(由Serhiy Storchaka在
issue 25971
中贡献。)
构建和C API变动
Python现在构建需要工具链中的一些C99支持。最值得注意的是，Python现在使用标准的整型类型和宏来替代诸如PY_LONG_LONG的自定义宏。欲知详情，见
PEP 7
和
issue 17884
。
带Android NDK和Android API level 21 (Android 5.0 Lollilop) 或者更高版本交叉编译CPython可以成功运行。虽然Android尚未是一个支持的平台，但是Python测试套件在Android模拟器上运行只有大约16个测试错误。见Android元问题
issue 26865
。
已添加--enable-optimizations配置标志。打开它将会激活昂贵的优化，例如PGO。(原始补丁由Intel的Alecsandru Patrascu在
issue 26539
中提出。)
当
PYMEM_DOMAIN_OBJ
 (例如：PyObject_Malloc())和
PYMEM_DOMAIN_MEM
 (例如：
PyMem_Malloc()
)域的分配函数被调用的时候，现在必须使用
GIL
。
新的
Py_FinalizeEx()
 API，它表示是否清除缓冲数据失败。 (由Martin Panter在
issue 5319
中贡献。)
PyArg_ParseTupleAndKeywords()
现在支持
仅位置参数
。仅位置参数是由空名称定义的。 (由Serhiy Storchaka在
issue 26282
中贡献)。
PyTraceback_Print方法现在省略了重复行的长串，变成"[Previous line repeated {count} more times]"。 (由Emanuel Barry在
issue 26823
中贡献。)
新的
PyErr_SetImportErrorSubclass()
函数指定要引发的
ImportError
的子类。 (由Eric Snow在
issue 15767
中贡献。)
新的
PyErr_ResourceWarning()
函数可以被用来生成一个
ResourceWarning
，提供资源分配的来源。(由Victor Stinner在
issue 26567
中贡献。)
新的
PyOS_FSPath()
函数返回一个
类路径(path-like)对象
的文件系统表示。(由Brett Cannon在
issue 27186
中贡献。)
PyUnicode_FSConverter()
和
PyUnicode_FSDecoder()
函数现在会接受
类路径(path-like)对象
。
其他改进
当使用
--version
 (短格式：
-V
)两次的时候，Python打印
sys.version
以获得详细信息。
$ ./python -VV    Python 3.6.0b4+ (3.6:223967b49e49+, Nov 21 2016, 20:55:04)    [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)]

弃用的模块，包以及函数
新的关键词
在后续的Python 3.7 中，async 和 await 将作为关键字使用， 因此不再建议使用它们作为变量名,类名，函数名以及模块名称。 
详见Python 3.5
**PEP492**
. 
从 Python 3.6 开始, async或await的使用将会引发[DeprecationWarning](
https://doc
http://
s.python.org/3.6/librar
y/exceptions.html#DeprecationWarning
"DeprecationWarning" )
已弃用的 Python 行为
Python 3.7 中, 在生成器中引发
StopIteration
异常，现在将会导致
DesprecationWarning
,并且触发
`RuntimeError`
. 查阅
PEP 479: Change StopIteration handlinginside generators
获得相关细节.
__aiter__()
方法现在被期望返回异步迭代器， 
而不是之前版本中的可等待迭代器，在 Python 3.6 中调用__aiter__()将会触发
DeprecationWarning
。 Python 3.7将会移除其的后向兼容性。(Contributed by Yury Selivanov in
issue27243
.)
反斜杠对现在不能再作为有效的转义字符串使用，其会导致 
DeprecationWarning
.在接下来的几个Python版本，其最终会成为一个语法错误 
SyntaxError
。(Contributed by Emanuel Barry in 
issue 27364
.)
在执行相对引用, 且__spec__ 或 __package__未定义时，转而调用__name__ 和 __path__模块的行为, 现在将会引发
ImportWarning
异常. (Contributed by Rose Ames in
issue25791
.)
弃用的 Python 模块，函数和方法
asynchat
为了支持
asyncio
，
asynchat
已被弃用。(Contributed 
by Mariatta in 
issue 25002
.)
asyncore
为了支持
asyncio
模块.
asyncore
模块已被弃用. (Contributed by Mariatta in 
issue 25002
.),
dbm
与其他
dbm
模块的的实现方式不同，
dbm.dumb
模块可以通过'rw'模式创建数据库 
并允许通过'r'模式来修改数据库，不过这种行为现在将被弃用，在Python3.8将会被移除。(Contributed by Serhiy Storchaka in 
issue21708
.)
distutils
Distribution构造器中extra_path参数现在被认为是过时的，如果在 Python 3.6中对其进行设置的话将会引发一个警告。 
对这个参数的支持将会在后续 Python版本中移除。详情请参阅
issue 27919
grp
getgrgid()
中对非整数参数的支持，现在已被移除。(Contributed by Serhiy Storchaka in 
issue 26129
.)
importlib
为了用来在之前的版本中支持
`importlib.abc.Loader.exec_module()`
，
importlib.machinery.SourceFileLoader.load_module()
和
`importlib.machinery.SourcelessFileLoader.load_module()`
，所以他们是
importlib
中
`importlib.abc.Loader.load_module()`
仅存的未被弃用的实现方式， 
不过在 Python 3.6 中，其也已经被弃用。
importlib.machinery.WindowsRegistryFinder
类已被弃用。 在 Python 3.6.0中，它被移动到
sys.meta_path
中， 不过在将来这可能会发生变化。
os
在
os
中对作为路径的通用
bytes-like objects
，
compile()
以及对类函数的非正式支持，现在已经弃用。
re
对正则式中间的内联标志(?letters)的支持已被弃用，并将在后续Python版本中移除。对正则式开头的标志的支持仍然被保留。(Contributed by Serhiy Storchaka in 
issue 22493
.)
ssl
OpenSSL 0.9.8, 1.0.0 和 1.0.1 已被弃用，不再支持。以后
ssl
模块至少需要 OpenSSL 1.0.2或者OpenSSL 1.1.0
为了支持context，SSL的相关参数如：certfile, keyfileandcheck_hostname
ftplib
,http.client,
imaplib
,
poplib
, 和
smtplib
已被弃用。(Contributed by Christian Heimes in
issue28022
.)
ssl
的部分协议及函数，现已被弃用。后续的 OpenSSL 版本中，部分现有特征将不再可用。 
为了引入新的API，其他的特征也已经被弃用。 (Contributed by Christian Heimes in 
issue 28022
 和 
issue26470
.)
tkinter
tkinter.tix
模块已被弃用。原
tkinter
的使用者，可以使用
tkinter.ttk
来代替。
venv
为了引入python3 -m venv命令，pyvenv 已被弃用。 这可以防止混淆何种 Python 解释器将被pyvenv连接 
以及何种 Python 解释器将被用在虚拟环境中。(Contributed by Brett Cannon in 
issue 25154
.)
弃用C API的函数和类型
现在，弃用未公开函数PyUnicode_AsEncodedObject()，PyUnicode_AsDecodedObject()，PyUnicode_AsEncodedUnicode()和PyUnicode_AsDecodedUnicode()。使用
通用的基于codec的API
来代替。
弃用构建选项
在非macOS UNIX平台上，现在默认打开--with-system-ffi配置标志。它也许可以用--without-system-ffi来禁用，但是这个标志的使用已经弃用了，并且在Python 3.7中将不会接受这个标志。macOS不受这个改动的影响。注意，许多OS发行版在构建它们的系统Python时已经使用了--with-system- 
ffi标志。
已移除
API和特性移除
正则表达式中'\'和一个ASCII字母组成的未知转义现在会触发错误。在
re.sub()
上的替换模板中，仍然允许使用它们，但是已经弃用了。
re.LOCALE
标志现在只能用于二进制模式。
移除inspect.getmoduleinfo() (自CPython 3.3起弃用)。
inspect.getmodulename()
应该被用于获取一个给定路径的模块名。(由Yury Selivanov在
issue 13248
中贡献。)
traceback.Ignore类和traceback.usage，traceback.modname，traceback.fullmodname，traceback.find_lines_from_code，traceback.find_lines，traceback.find_strings，traceback.find_executable_lines方法已从
traceback
模块移除。它们是自Python 3.2起弃用的未公开方法，并且可以从私有方法获得等价的功能。
移除
tkinter
 widget类中的tk_menuBar()和tk_bindForTraversal()哑方法 (自Tk 4.0起，相应的Tk命令已废弃)。
zipfile.ZipFile
类的
open()
方法不再支持'U'模式 (自Python 3.4起弃用)。使用
io.TextIOWrapper
来在
universal newlines
模式下读取压缩文本文件。
已移除未公开的IN, CDROM, DLFCN, TYPES, CDIO, 和STROPTS模块。它们在平台特定的Lib/plat-*/目录中可用，但是慢慢过时了，跨平台不一定可用，并且未维护。创建这些模块的脚本在源代码发行版中仍然可以找到，位于
Tools/scripts/h2py.py
中。
已移除弃用的asynchat.fifo类。
移植到Python 3.6
本节列出了与之前版本相比，一些特性的更改和bug的修复，这些可能会影响到你代码的编写。
'python'命令行操作变更
默认情况下，用COUNT_ALLOCS，SHOW_ALLOC_COUNT或SHOW_TRACK_COUNT等宏定义的特殊python输出是关闭的。 它可以使用-X showalloccount选项重新启用. 它现在输出到stderr而不是stdout。 (由Serhiy Storchaka撰写在 
issue 23034
.)
Python API中的变化（部分翻译）
open()
 'U' 模式不再允许使用'+'拼接. (由Jeff Balogh and John O'Connor撰写在 
issue 2091
.)
sqlite3
 不允许在DDL语句之前隐式地提交打开的事务。
在Linux系统上, 
os.urandom()
 现在为了增强安全性，系统会一直阻塞直到系统urandom熵池被初始化。
当
importlib.abc.Loader.exec_module()
 被定义时,
importlib.abc.Loader.create_module()
 也必须被定义.
PyErr_SetImportError()
 现在被设置为
TypeError
当它的** msg **参数没有设置。 以前只返回“NULL”。
compileall
模块中的函数现在返回布尔类型的值，而不是用1或0来表示成功或失败. 由于布尔值是整数的子类，如果你对'1'或'0'进行身份检查，这只应该是一个问题。 查看
issue 25768
.
读取
urllib.parse.urlsplit（）
和[urlparse（）]的port属性现在引发超出范围值的
ValueError
 ，而不是返回
None
. 查看 
issue 20059
.
imp
 模块现在代替原来的
PendingDeprecationWarning
抛出
DeprecationWarning
告警 .
以下模块已将缺少的API添加到其 __all__ 属性中，匹配文档说明API: 
calendar
, 
cgi
, 
csv
, 
ElementTree
, 
enum
,
fileinput
, 
ftplib
, 
logging
, 
mailbox
, 
mimetypes
,
optparse
, 
plistlib
, 
smtpd
, 
subprocess
, 
tarfile
,
threading
 and 
wave
. 这意味着在使用import *引入时，有一定的变化 . (由Joel Taddei and Jacek Kołodziej i撰写在
issue 23883
.)
当执行相对导入时，如果__package__不等于__spec __。parent，那么 
ImportWarning
 警告将被抛出. (由 Brett Cannon 撰写在
issue 25791
.)
当执行相对导入并且没有已知父包时，则将抛出
ImportError
异常。 以前，是抛出
SystemError
异常。 (由Brett Cannon 撰写在 
issue 18018
.)
基于
socketserver
模块的服务器，包括
http.server
，
xmlrpc.server
和[wsgiref.simple_server] ，现在只捕获从
Exception
派生的异常。 因此，如果一个请求处理程序引发了
[SystemExit]
或[KeyboardInterrupt]] 
300
异常，则
handle_error（）
 异常不再被调用，同时异常会终止单线程的服务器。 (由Martin Panter 撰写在
issue 23430
.)
如果用户没有相关权限，
spwd.getspnam()
现在抛出
PermissionError
 异常，代替原来的
KeyError
.
(如 EBADF) 这样的底层调用错误，
socket.socket.close()
方法现在会抛出异常。 (由Martin Panter撰写于
issue 26685
.)
在C API上的改动
旧的
PyMem_Malloc()
分配算符族将使用新的
pymalloc分配算符
，替换掉了系统原有的’malloc()’。应用程序在没有捕获GIL时调用
PyMem_Malloc()
会导致崩溃。可通过设置
pythonmalloc
环境变量去’debug’来实现应用程内存的分配。详情请看
问题26429
。
Py_Exit()
（和新的主注释器），如果刷新缓存失败，将覆盖当前状态。详情请看
问题5319
CPython 字节码的更改
在Python 3.6中将会出现几个关于
字节码
要更新。 
3.6.
新的Python注释器将使用16位词码去替代老的字符码。（感谢Demur Rumed在Serhiy Storchaka和Victor Stinner
问题26647
和
问题28050
中做出贡献后的审查）
将启用新的
FORMAT_VALUE
和
BUILD_STRING
 操作码作为一部分格式化字符串。（感谢Eric Smith在
问题25483
和Serhiy Storchaka在
问题27078
的贡献）
将启用新的
BUILD_CONST_KEY_MAP
操作码并伴随常量关键字优化创建字典的过程。（感谢Serhiy Storchaka 提出的
问题27140
.）
为了更好的表现和更快捷的启动, 已经对调用操作码的功能进行了深度重做。
MAKE_FUNCTION
,
CALL_FUNCTION
,
CALL_FUNCTION_KW
 以及BUILD_MAP_UNPACK_WITH_CALL 这些操作码已经做了修改，并添加了新的CALL_FUNCTION_EX 和BUILD_TUPLE_UNPACK_WITH_CALL。而CALL_FUNCTION_VAR,CALL_FUNCTION_VAR_KW 和MAKE_CLOSURE则在新的Python中被移除。（感谢Demur Rumed在
问题27905
中的贡献以及Serhiy Storchaka在
问题27213
、
问题28257
中的贡献）
添加了
SETUP_ANNOTATIONS
 和 
STORE_ANNOTATION
操作码，用于支持新的
变量注解语法
。（感谢Ivan Levkivskyi在
问题27985
中的贡献）
(C) 
Copyright
2001-2016,Python软件基金会版权所有。Python软件基金会是一个非营利性组织。
欢迎捐赠
转载需得到Py字幕组授权，联系邮箱：sinoandywong@gmail.com
