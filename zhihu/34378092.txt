这是一篇正经的数据分析案例。
去年12月初，在经过四年多的积累后，编程教室微信公众号的关注人数突破
10万
人。（可回顾 
最开始我也没有想过会有这么一天…
）
10万人只是另一个开始，让我感到责任更大了。如果不写出更多更好质量的文章和教程，也对不起大家的关注啊。人数不是目的，内容才是王道。
但是嘛，偶尔也会 yy 一下，什么时候我们的关注数能到达更高的量级，比如，
100万
？😏
既然 Python 可以用来做数据分析，何不根据我们公众号现有的用户增长数据来分析一下，
什么时候可以迎来第100万个关注者
？
说干就干！（
不想看过程的直接拉到最后看结论
）
微信后台可以导出用户增长数据的 excel 表格。数据从2013年7月开始，每次导出时间间隔最多一年。我们编程教室的账号是2013年6月份创建的，虽然差了一点点，但也足够了。
把几年的数据合并一下，我们这次只关注其中的“
累积关注人数
”和“
时间
”。通过 
matplotlib
 把增长曲线绘制出来：
显然这不是一个简单的匀速增长曲线，而是
加速增长
！这让我甚感欣慰。
核心代码
# x_data 时间列表


# y_data 用户数列表


plt
.
plot
(
x_data
,
 
y_data
,
'g'
)


plt
.
show
()


那么从数学上来看，有没有能够较好拟合这个增长曲线的模型呢？我们来尝试几个最常用的拟合曲线，看看效果。
多项式拟合
多项式拟合即用形如
的函数曲线来拟合现有的数据。比如三次多项式拟合就是对公式
中的4个系数求解，使得函数曲线与数据“
最接近
”。
至于怎样才算是“最接近”？直观来考虑，就是拟合曲线和实际曲线上对应点的距离最短，即绝对值最小。以我们的例子来说，就是
拟合函数算出的每天总关注人数和当天实际总关注人数的差
，我们要让这个差值的总和最小。
但因为绝对值之和不容易处理，所以通常我们选择差值的平分和来替代。这就是“
最小二乘法
”。
更数学化的表述就是，我们要找出拟合曲线中的一组参数 c，使得模型与实际值上每一点的残差 ek 的平方和最小。
我们绘制了从
1次多项式
（线性函数）到
9次多项式
的拟合曲线：
因为我们的目的是要预测之后的趋势，所以选择的拟合天数要大于实际数据的天数。
从图上就能比较直观地就看出，1次、2次等低阶曲线不能很好地贴合原数据，
3~8次效果都还不错
，而9次曲线在不久之后就会因为过拟合而产生不合理的波动。
对于多项式拟合，
numpy
 提供了现成的 
polyfit
 和 
poly1d
 函数供调用。
核心代码
# x_np 实际数据，时间
# y_np 实际数据，用户数
# x_fit 拟合数据，时间
coeff = np.polyfit(x_np, y_np, k)
poly = np.poly1d(coeff)
y_fit = poly(x_fit)
plt.plot(x_fit, y_fit)

指数拟合
指数函数是重要的基本初等函数之一，这里我们通过确定以 e 为底的函数
中3个参数 a、b、c 来进行拟合。
看起来拟合效果还不错。
numpy
 没有提供直接的指数拟合函数，但我们可以通过 
scipy
 库里的 
scipy.optimize.leastsq
 实现最小二乘法。
核心代码
def func(x, p):
    a,b,c = p
    return a * np.exp(b * x) + c

# 残差函数
def residuals(p, y, x):
    return y - func(x, p)

pe = [1, 0.0001, 1]  # 初始预测值
plsq = leastsq(residuals, pe, args=(y_np, x_np))
y_fit = func(x_fit, plsq[0])
plt.plot(x_fit, y_fit)

幂函数拟合
幂函数和指数函数有点类似，只不过我们使用的函数是
同样也是3个参数。
拟合的效果与前面的指数函数有点相似。代码中，我们也只要在刚才的基础上，修改一下 
func
 函数即可。
核心代码
def func(x, p):
    a,b,c = p
    return a * x ** b + c

拟合效果评价
以上几种方法虽然看起来都不错，但结果毕竟有不小的差异，究竟哪一个更“科学”一点呢？
我们通过几个评价指标来衡量一下：
均方根误差（RMSE）
：真实值和预测值之差的平方和。这其实就是我们拟合时的判断基础啊。只不过加上了根号，使得结果的量纲更加合理（否则就是均方误差MSE）。
平均绝对误差（MAE）
：和 MSE 的区别就在于直接使用真实值和预测值之差的绝对值作为衡量标准。
R平方（R2）
 ：因为 MSE 结果的大小取决于不同数据的本身数值大小，并不统一。R2 则是在此基础上，将其转换至 0~1 之间，以便于评价。
以上指标，
sklearn
 库均在 
metrics
 中提供了方法。
核心代码
# ploy 拟合函数
rmse = sqrt(metrics.mean_squared_error(y_np, poly(x_np)))
mae = metrics.mean_absolute_error(y_np, poly(x_np))
r2 = metrics.r2_score(y_np, poly(x_np))

当然，这些指标都是基于拟合函数与已有数据的判断，对于未来的预测，谁也说不准，只能是“仅供参考”。毕竟如果可以预知未来，那我大概早就 all in 比特币了。🤦
最终结果
综合结果来看，
编程教室的百万用户很可能在2019~2022年之间到来
。对3~8次多项式、指数函数、幂函数的预测结果做个简单的平均，那么这一天就是：
2020年5月27日
只需要  
811
 天，想想还有点小激动呢。
忽然，我想到了那个诡异的9次函数，说来也不是不可能哦：当人数过了40万，因为某个不小心被封了号，一切归零。这也不是什么新鲜事儿。
所以，我还是老老实实写教程吧。猥琐发育，别浪！
数据及完整代码已上传，需要的同学请在公众号（Crossin的编程教室）里回复 
百万
════
其他文章及回答：
新手引导
 | 
学编程的弯路
 | 
如何自学Python
Crossin的编程教室
微信公众号ID：crossincode
